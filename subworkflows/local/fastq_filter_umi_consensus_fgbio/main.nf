//
// Runs FGBIO tools to filter UMI tags from FASTQ reads
// This pipeline is based on 'fgbio Best Practices'
// https://github.com/fulcrumgenomics/fgbio/blob/main/docs/best-practice-consensus-pipeline.md
//

include { FGBIO_FASTQTOBAM                  as FASTQTOBAM                  } from '../../../modules/nf-core/fgbio/fastqtobam/main'
include { FGBIO_CORRECTUMIS                 as CORRECTUMIS                 } from '../../../modules/local/fgbio/correctumis/main'
include { SAMTOOLS_BAM2FQ                   as BAM2FQ_UMI                  } from '../../../modules/nf-core/samtools/bam2fq/main'
include { BWA_MEM                           as ALIGN_UMI                   } from '../../../modules/nf-core/bwa/mem/main'
include { FGBIO_ZIPPERBAMS                  as ZIPPERBAMS_UMI              } from '../../../modules/nf-core/fgbio/zipperbams/main'
include { SAMTOOLS_BAM2FQ                   as BAM2FQ_CONS                 } from '../../../modules/nf-core/samtools/bam2fq/main'
include { BWA_MEM                           as ALIGN_CONS                  } from '../../../modules/nf-core/bwa/mem/main'
include { FGBIO_ZIPPERBAMS                  as ZIPPERBAMS_CONS             } from '../../../modules/nf-core/fgbio/zipperbams/main'
include { FGBIO_GROUPREADSBYUMI             as GROUPREADSBYUMI             } from '../../../modules/nf-core/fgbio/groupreadsbyumi/main'
include { FGBIO_CALLMOLECULARCONSENSUSREADS as CALLMOLECULARCONSENSUSREADS } from '../../../modules/nf-core/fgbio/callmolecularconsensusreads/main'
include { FGBIO_FILTERCONSENSUSREADS        as FILTERCONSENSUSREADS        } from '../../../modules/nf-core/fgbio/filterconsensusreads/main'
include { SAMTOOLS_SORT                     as SORTCONSENSUSREADS          } from '../../../modules/nf-core/samtools/sort/main'

workflow FASTQ_FILTER_UMI_CONSENSUS_FGBIO {
    take:
    reads                     // channel: [mandatory] [ val(meta1), [ reads ] ]
    fasta                     // channel: [mandatory] [ val(meta2), [ fasta ] ]
    dict                      // channel: [mandatory] [ val(meta3), [ dict  ] ]
    bwa_index                 // channel: [mandatory] [ val(meta4), [ index ] ]
    umi_file                  // channel: [optional]  /path/to/file/txt - list of expected UMIs
    max_mismatches            // integer: [optional]  used with umi_file - default: 1
    min_distance              // integer: [optional]  used with umi_file - default: 2
    groupreadsbyumi_strategy  // string:  [mandatory] grouping strategy - default: "Adjacency"
    min_reads                 // integer: [mandatory] the min num of reads for a consensus base/read - default: 3
    min_base_quality          // integer: [mandatory] mask (make 'N') consensus bases with Q < - default: 45
    max_base_error_rate       // real:    [mandatory] the maximum error rate for a single consensus base - default: 0.2

    main:
    versions = Channel.empty()

    // Phase 1: FASTQ -> Grouped BAM

    // params.umi_read_structure is passed out as ext.args
    // FASTQ reads are converted into a tagged unmapped BAM file (uBAM)
    FASTQTOBAM(reads)

    // Our hero - or not
    ubam = FASTQTOBAM.out.bam

    // Corrects UMIs stored in BAM files when a set of fixed UMIs is in use
    if (umi_file) {
        CORRECTUMIS(ubam, umi_file, max_mismatches, min_distance)
        ubam     = CORRECTUMIS.out.bam
        versions = versions.mix(CORRECTUMIS.out.versions)
    }

    split = false // For SAMTOOLS_BAM2FQ
    sort  = false // For BWA_MEM

    // Takes an unmapped BAM and generates an aligned BAM using bwa and ZipperBams
    BAM2FQ_UMI(ubam, split)
    ALIGN_UMI(BAM2FQ_UMI.out.reads, bwa_index, [[id:'no_fasta'], []], sort)
    ZIPPERBAMS_UMI(ubam, ALIGN_UMI.out.bam, fasta, dict)

    // Group reads together that appear to have come from the same original molecule
    GROUPREADSBYUMI(ZIPPERBAMS_UMI.out.bam, groupreadsbyumi_strategy)

    // Phase 2(a): GroupedBam -> Filtered Consensus, R&D Version

    // Call consensus sequences from reads with the same unique molecular tag
    call_min_reads              = 1   // min num of reads to consensus base
    call_min_input_base_quality = 20  // filter raw reads bellow this Q
    CALLMOLECULARCONSENSUSREADS(GROUPREADSBYUMI.out.bam, call_min_reads, call_min_input_base_quality)

    // Consensus uBam -> Consensus Mapped BAM
    BAM2FQ_CONS(CALLMOLECULARCONSENSUSREADS.out.bam, split)
    ALIGN_CONS(BAM2FQ_CONS.out.reads, bwa_index, [[id:'no_fasta'], []], sort)
    ZIPPERBAMS_CONS(CALLMOLECULARCONSENSUSREADS.out.bam, ALIGN_CONS.out.bam, fasta, dict)

    // Filters consensus reads generated by CallMolecularConsensusReads
    FILTERCONSENSUSREADS(ZIPPERBAMS_CONS.out.bam, fasta, min_reads, min_base_quality, max_base_error_rate)

    // Sort final BAM file
    SORTCONSENSUSREADS(FILTERCONSENSUSREADS.out.bam, [[id:'no_fasta'], []])

    versions = versions.mix(FASTQTOBAM.out.versions)
    versions = versions.mix(BAM2FQ_UMI.out.versions)
    versions = versions.mix(ALIGN_UMI.out.versions)
    versions = versions.mix(ZIPPERBAMS_UMI.out.versions)
    versions = versions.mix(GROUPREADSBYUMI.out.versions)
    versions = versions.mix(CALLMOLECULARCONSENSUSREADS.out.versions)
    versions = versions.mix(BAM2FQ_CONS.out.versions)
    versions = versions.mix(ALIGN_CONS.out.versions)
    versions = versions.mix(ZIPPERBAMS_CONS.out.versions)
    versions = versions.mix(FILTERCONSENSUSREADS.out.versions)
    versions = versions.mix(SORTCONSENSUSREADS.out.versions)

    emit:
    bam      = SORTCONSENSUSREADS.out.bam  // channel: [ val(meta), [ bam ] ]
    versions = versions                    // channel: [ versions.yml ]
}
